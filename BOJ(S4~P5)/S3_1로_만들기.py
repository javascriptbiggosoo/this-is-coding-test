# 1트, 이코테에서 먼저 보지 않았다면 못풀었을 것 같다.
# 분명 어렵지만 standard한 문제이기 때문에 한 번 풀어보면 이걸로 또 여러 문제들을 공략 할 수 있을듯
n = int(input())
d = [0] * (n + 2)  # n으로 받는 값이 1인 경우 for문 에러

d[1] = 0
d[2] = 1

# 찾는 값은 d[n]이다. n보다 index가 낮은 쪽이 오히려 연산 횟수가 많을 수 있다. 여기서 방법을 고민하기가 어렵다.
# 하지만 어쨋든 d[n] 이전에 있던 숫자중 하나에 연산을 한 번 더 하면 그게 d[n]이란 사실까지는 또 쉽게 떠오른다.

# 처음엔 낮은애들끼리 어떻게 조합을 해야하나 싶었는데.. 각 숫자별로 연산횟수를 메모해두고 d[n]이 연산할 수 있는 경우(여기선 3번)를 전부 따진 후
# 그 중 연산횟수가 가장 적은 값에서 연산횟수 1만 더하는 방식이면, 클리어다
for i in range(3, n + 1):
    d[i] = d[i - 1] + 1
    if i % 2 == 0:
        d[i] = min(d[i], d[i // 2] + 1)
    if i % 3 == 0:
        d[i] = min(d[i], d[i // 3] + 1)
print(d[n])
